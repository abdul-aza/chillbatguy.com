<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChillBat Game</title>
    
    <!-- Core dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.87.6/lib/index.iife.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.8/lib/index.iife.min.js?v=1"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    
    <style>
        /* Base styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }
        
        #root {
            width: 100vw;
            height: 100vh;
        }

        /* Navigation */
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            transition: background 0.3s ease;
        }
        
        .back-button:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        /* Game elements */
        .moon {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(90deg, #ffffff, #f4f4f4);
            box-shadow: 
                inset -22px 0 30px rgba(0, 0, 0, 0.2),
                0 0 30px rgba(255, 255, 255, 0.3);
            position: relative;
        }

        .moon::after {
            content: '';
            position: absolute;
            top: 12px;
            left: 12px;
            width: 18px;
            height: 18px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            box-shadow: 
                30px 22px 0 -4px rgba(0, 0, 0, 0.1),
                15px 45px 0 -6px rgba(0, 0, 0, 0.1);
        }

        /* UI Components */
        .leaderboard {
            position: fixed;
            left: 20px;
            top: 80px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 100;
            min-width: 200px;
        }

        .stats {
            position: fixed;
            right: 20px;
            top: 80px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            z-index: 100;
            min-width: 200px;
        }

        .transaction-status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            z-index: 1000;
            text-align: center;
        }

        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.5; }
        }

        .star {
            animation: pulse 3s infinite;
        }

        /* Game Objects */
        .obstacle {
            transition: transform 0.1s linear;
        }

        .bat {
            transition: transform 0.2s ease-out;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .leaderboard, .stats {
                font-size: 14px;
                min-width: 150px;
            }
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Back to Home</a>
    <div id="root"></div>

    <script type="text/babel">
        // Constants and Configuration
        const CONSTANTS = {
            TOKEN_ADDRESS: "HwS3GFzAE8BFpL5jTu6Sm5DyMofaGRjpNrzq9yMS6yXE",
            TREASURY_WALLET: "7gitjQR4y3JdchHaGLm8XLFqYkA8LACm1dXUCk6ArpuQ",
            ENTRY_FEE: 1000,
            WINNING_PAYOUT: 3000,
            SCORE_MULTIPLIER: 50,
            WIN_THRESHOLD: 60,
            GAME_PHYSICS: {
                GRAVITY: 1.2,
                JUMP_FORCE: -18,
                BASE_SPEED: 7.5
            }
        };

        // Utility Functions
        const Utils = {
            formatWalletAddress: (address) => {
                return `${address.slice(0, 6)}...${address.slice(-4)}`;
            },
            
            getRandomNumber: (min, max) => {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
        };

        // Solana Integration
        const SolanaManager = {
            connection: new solanaWeb3.Connection(
                solanaWeb3.clusterApiUrl("devnet"),
                'confirmed'
            ),

            async connectWallet() {
                try {
                    if (!window.solana?.isPhantom) {
                        throw new Error("Phantom wallet not detected");
                    }
                    
                    const response = await window.solana.connect();
                    return response.publicKey.toString();
                } catch (error) {
                    console.error("Wallet connection error:", error);
                    throw error;
                }
            },

            async checkTokenBalance(walletAddress) {
                try {
                    const publicKey = new solanaWeb3.PublicKey(walletAddress);
                    const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
                        publicKey,
                        { mint: new solanaWeb3.PublicKey(CONSTANTS.TOKEN_ADDRESS) }
                    );

                    if (tokenAccounts.value.length === 0) return 0;
                    
                    return tokenAccounts.value[0].account.data.parsed.info.tokenAmount.uiAmount;
                } catch (error) {
                    console.error("Balance check error:", error);
                    throw error;
                }
            },

            async processEntryFee(walletAddress) {
                try {
                    const provider = window.solana;
                    const wallet = provider.publicKey;
                    
                    const fromTokenAccount = await splToken.getAssociatedTokenAddress(
                        new solanaWeb3.PublicKey(CONSTANTS.TOKEN_ADDRESS),
                        wallet
                    );

                    const toTokenAccount = await splToken.getAssociatedTokenAddress(
                        new solanaWeb3.PublicKey(CONSTANTS.TOKEN_ADDRESS),
                        new solanaWeb3.PublicKey(CONSTANTS.TREASURY_WALLET)
                    );

                    const transaction = new solanaWeb3.Transaction().add(
                        splToken.createTransferInstruction(
                            fromTokenAccount,
                            toTokenAccount,
                            wallet,
                            CONSTANTS.ENTRY_FEE * Math.pow(10, 9)
                        )
                    );

                    const { blockhash } = await this.connection.getLatestBlockhash();
                    transaction.recentBlockhash = blockhash;
                    transaction.feePayer = wallet;

                    const signed = await provider.signTransaction(transaction);
                    const signature = await this.connection.sendRawTransaction(signed.serialize());
                    await this.connection.confirmTransaction(signature);
                    
                    return true;
                } catch (error) {
                    console.error("Entry fee processing error:", error);
                    throw error;
                }
            },

            async sendReward(walletAddress) {
                // Similar implementation to processEntryFee but in reverse direction
                // and with WINNING_PAYOUT amount
                // Implementation details omitted for brevity but follow the same pattern
            }
        };

        // Game State Management
        const GameStateManager = {
            getHighScores() {
                const scores = localStorage.getItem('chillbat_scores');
                return scores ? JSON.parse(scores) : [];
            },

            addScore(wallet, score) {
                let scores = this.getHighScores();
                scores.push({
                    wallet: Utils.formatWalletAddress(wallet),
                    score: Math.floor(score / CONSTANTS.SCORE_MULTIPLIER),
                    date: new Date().toISOString()
                });
                scores.sort((a, b) => b.score - a.score);
                scores = scores.slice(0, 10);
                localStorage.setItem('chillbat_scores', JSON.stringify(scores));
            },

            getPlayerStats(wallet) {
                const stats = localStorage.getItem(`chillbat_stats_${wallet}`);
                return stats ? JSON.parse(stats) : {
                    gamesPlayed: 0,
                    highScore: 0,
                    totalEarned: 0,
                    totalSpent: 0
                };
            },

            updatePlayerStats(wallet, gameResult) {
                const stats = this.getPlayerStats(wallet);
                stats.gamesPlayed++;
                stats.highScore = Math.max(
                    stats.highScore,
                    Math.floor(gameResult.score / CONSTANTS.SCORE_MULTIPLIER)
                );
                stats.totalEarned += gameResult.won ? CONSTANTS.WINNING_PAYOUT : 0;
                stats.totalSpent += CONSTANTS.ENTRY_FEE;
                localStorage.setItem(
                    `chillbat_stats_${wallet}`,
                    JSON.stringify(stats)
                );
                return stats;
            }
        };

        // React Components
        const WalletConnection = ({ onSuccess }) => {
            const [connecting, setConnecting] = useState(false);
            const [error, setError] = useState(null);
            const [transactionStatus, setTransactionStatus] = useState('');
            
            const connectWallet = async () => {
                try {
                    setConnecting(true);
                    setError(null);
                    setTransactionStatus('Connecting wallet...');
                    
                    const walletAddress = await SolanaManager.connectWallet();
                    const balance = await SolanaManager.checkTokenBalance(walletAddress);
                    
                    if (balance < CONSTANTS.ENTRY_FEE) {
                        throw new Error(`Insufficient tokens. Need ${CONSTANTS.ENTRY_FEE} $ChillBat to play.`);
                    }
                    
                    setTransactionStatus('Processing entry fee...');
                    await SolanaManager.processEntryFee(walletAddress);
                    
                    onSuccess(walletAddress);
                } catch (error) {
                    setError(error.message);
                } finally {
                    setConnecting(false);
                    setTransactionStatus('');
                }
            };

            return (
                <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-75">
                    <div className="bg-gray-900 p-8 rounded-lg max-w-md w-full mx-4">
                        <h2 className="text-2xl text-white font-bold mb-6">
                            Welcome to ChillBat Game
                        </h2>
                        
                        <p className="text-gray-300 mb-6">
                            Entry Fee: {CONSTANTS.ENTRY_FEE} $ChillBat<br/>
                            Win {CONSTANTS.WINNING_PAYOUT} $ChillBat by reaching score {CONSTANTS.WIN_THRESHOLD}!
                        </p>
                        
                        <button
                            onClick={connectWallet}
                            disabled={connecting}
                            className="w-full bg-purple-600 text-white py-3 px-6 rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50"
                        >
                            {connecting ? 'Connecting...' : 'Connect Wallet to Play'}
                        </button>
                        
                        {error && (
                            <p className="text-red-500 mt-4 text-center">{error}</p>
                        )}
                        
                        {transactionStatus && (
                            <p className="text-white text-center mt-4">
                                {transactionStatus}
                            </p>
                        )}
                    </div>
                </div>
            );
        };

        const Game = () => {
            // State management
            const [gameState, setGameState] = useState({
                started: false,
                over: false,
                score: 0,
                batPosition: 300,
                velocity: 0,
                obstacles: [],
                backgroundOffset: 0,
                speedMultiplier: 1
            });
            
            const [walletConnected, setWalletConnected] = useState(false);
            const [walletAddress, setWalletAddress] = useState(null);

            // Game loop and physics
            useEffect(() => {
                if (!gameState.started || gameState.over) return;

                const gameLoop = setInterval(() => {
                    setGameState(prev => {
                        const newState = { ...prev };
                        
                        // Update bat physics
                        newState.velocity += CONSTANTS.GAME_PHYSICS.GRAVITY;
                        newState.batPosition += newState.velocity;
                        
                        // Check boundaries
                        if (newState.batPosition < 0 || newState.batPosition > 900) {
                            newState.over = true;
                            return newState;
                        }
                        
                        // Update obstacles
                        const speed = CONSTANTS.GAME_PHYSICS.BASE_SPEED * newState.speedMultiplier;
                        newState.backgroundOffset = (newState.backgroundOffset + speed) % 1500;
                        
                        newState.obstacles = newState.obstacles
                            .map(obs => ({
                                ...obs,
                                x: obs.x - speed
                            }))
                            .filter(obs => obs.x > -90);

                        //// Generate new obstacles
                        if (newState.obstacles.length === 0 || 
                            newState.obstacles[newState.obstacles.length - 1].x < 600) {
                            newState.obstacles.push({
                                x: 1200,
                                height: Utils.getRandomNumber(150, 600),
                                gap: Utils.getRandomNumber(225, 525)
                            });
                        }

                        // Collision detection
                        const BAT_SIZE = 96;
                        newState.obstacles.forEach(obstacle => {
                            const batBox = {
                                left: 150,
                                right: 150 + BAT_SIZE,
                                top: newState.batPosition,
                                bottom: newState.batPosition + BAT_SIZE
                            };

                            const obstacleBoxUpper = {
                                left: obstacle.x,
                                right: obstacle.x + 96,
                                top: 0,
                                bottom: obstacle.height
                            };

                            const obstacleBoxLower = {
                                left: obstacle.x,
                                right: obstacle.x + 96,
                                top: obstacle.height + obstacle.gap,
                                bottom: 900
                            };

                            if (detectCollision(batBox, obstacleBoxUpper) ||
                                detectCollision(batBox, obstacleBoxLower)) {
                                newState.over = true;
                            }
                        });

                        // Update score and speed
                        newState.score++;
                        newState.speedMultiplier = 1 + (Math.floor(newState.score / 200) * 0.08);

                        return newState;
                    });
                }, 20);

                return () => clearInterval(gameLoop);
            }, [gameState.started, gameState.over]);

            // Collision detection helper
            const detectCollision = (box1, box2) => {
                return box1.left < box2.right &&
                       box1.right > box2.left &&
                       box1.top < box2.bottom &&
                       box1.bottom > box2.top;
            };

            // Handle jump
            const handleJump = useCallback(() => {
                if (!gameState.over) {
                    setGameState(prev => ({
                        ...prev,
                        velocity: CONSTANTS.GAME_PHYSICS.JUMP_FORCE
                    }));
                }
            }, [gameState.over]);

            // Handle game start/restart
            const startGame = () => {
                setGameState({
                    started: true,
                    over: false,
                    score: 0,
                    batPosition: 300,
                    velocity: 0,
                    obstacles: [],
                    backgroundOffset: 0,
                    speedMultiplier: 1
                });
            };

            // Handle wallet success
            const handleWalletSuccess = (address) => {
                setWalletConnected(true);
                setWalletAddress(address);
            };

            // Game end handling
            useEffect(() => {
                if (gameState.over && walletAddress) {
                    const finalScore = Math.floor(gameState.score / CONSTANTS.SCORE_MULTIPLIER);
                    const gameResult = {
                        score: gameState.score,
                        won: finalScore >= CONSTANTS.WIN_THRESHOLD
                    };

                    GameStateManager.addScore(walletAddress, gameState.score);
                    GameStateManager.updatePlayerStats(walletAddress, gameResult);

                    if (gameResult.won) {
                        SolanaManager.sendReward(walletAddress)
                            .catch(error => console.error('Reward sending failed:', error));
                    }
                }
            }, [gameState.over, walletAddress]);

            // Event listeners
            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (e.code === 'Space') {
                        if (!gameState.started) {
                            startGame();
                        } else {
                            handleJump();
                        }
                    }
                };

                window.addEventListener('keypress', handleKeyPress);
                return () => window.removeEventListener('keypress', handleKeyPress);
            }, [gameState.started, handleJump]);

            if (!walletConnected) {
                return <WalletConnection onSuccess={handleWalletSuccess} />;
            }

            // Render game
            return (
                <div 
                    className="relative w-full h-screen overflow-hidden"
                    onClick={gameState.started ? handleJump : startGame}
                >
                    {/* Background */}
                    <div className="absolute inset-0 bg-gradient-to-b from-black via-blue-900 to-purple-900">
                        {/* Stars */}
                        {Array.from({ length: 75 }).map((_, i) => (
                            <div
                                key={i}
                                className="absolute w-1.5 h-1.5 bg-white rounded-full star"
                                style={{
                                    top: `${Math.random() * 100}%`,
                                    left: `${Math.random() * 100}%`,
                                    animationDelay: `${Math.random() * 2}s`
                                }}
                            />
                        ))}

                        {/* Moon */}
                        <div className="absolute top-12 right-24">
                            <div className="moon" />
                        </div>
                    </div>

                    {/* Game UI */}
                    <div className="absolute top-6 right-6 text-6xl text-white font-bold">
                        {Math.floor(gameState.score / CONSTANTS.SCORE_MULTIPLIER)}
                    </div>

                    {/* Bat */}
                    <div 
                        className="bat absolute left-[40vw] w-24 h-24"
                        style={{ 
                            top: `${gameState.batPosition}px`,
                            transform: `rotate(${gameState.velocity * 2}deg)`
                        }}
                    >
                        <img 
                            src="IMG_4964_2.png" 
                            alt="ChillBat"
                            className="w-full h-full object-contain"
                        />
                    </div>

                    {/* Obstacles */}
                    {gameState.obstacles.map((obstacle, index) => (
                        <React.Fragment key={index}>
                            {/* Upper obstacle */}
                            <div 
                                className="obstacle absolute w-24"
                                style={{
                                    left: `${obstacle.x}px`,
                                    height: `${obstacle.height}px`,
                                    top: 0
                                }}
                            >
                                <div className="absolute inset-0 bg-gradient-to-b from-purple-500 to-purple-700 rounded-lg border-2 border-purple-400" />
                            </div>
                            {/* Lower obstacle */}
                            <div 
                                className="obstacle absolute w-24"
                                style={{
                                    left: `${obstacle.x}px`,
                                    top: `${obstacle.height + obstacle.gap}px`,
                                    bottom: 0
                                }}
                            >
                                <div className="absolute inset-0 bg-gradient-to-b from-purple-700 to-purple-500 rounded-lg border-2 border-purple-400" />
                            </div>
                        </React.Fragment>
                    ))}

                    {/* Game overlay */}
                    {(!gameState.started || gameState.over) && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-50 backdrop-blur-sm">
                            <h1 className="text-7xl text-white font-bold mb-6">
                                {gameState.over ? 'Game Over!' : 'ChillBat Game'}
                            </h1>
                            <p className="text-3xl text-white mb-12">
                                {gameState.over 
                                    ? `Score: ${Math.floor(gameState.score / CONSTANTS.SCORE_MULTIPLIER)}`
                                    : 'Click or Press Space to Start'}
                            </p>
                            {gameState.over && (
                                <button 
                                    onClick={startGame}
                                    className="px-8 py-4 bg-purple-600 text-white text-xl rounded-lg hover:bg-purple-700 transition-colors"
                                >
                                    Play Again
                                </button>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // Mount the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>
</body>
</html>
